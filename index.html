
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pattern Puzzle</title>
  <style>
    body { font-family: sans-serif; text-align: center; background: #111; color: white; }
    canvas { margin-top: 10px; border: 2px solid white; background: black; }
    button { margin: 5px; padding: 10px 20px; font-size: 1rem; }
  </style>
</head>
<body>
  <h1>Pattern Puzzle</h1>
  <div id="info">
    <div>Level: <span id="level">1</span></div>
    <div>Score: <span id="score">0</span></div>
  </div>
  <canvas id="gameCanvas" width="320" height="320"></canvas>
  <br/>
  <button onclick="togglePattern()">Toggle Pattern</button>
  <button onclick="undoMove()">Undo</button>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const gridSize = 4;
    const tileSize = canvas.width / gridSize;
    let pattern = [];
    let selected = [];
    let level = 1;
    let score = 0;
    let showingPattern = false;
    let moveHistory = [];

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const idx = y * gridSize + x;
          ctx.fillStyle = selected.includes(idx)
            ? "#0f0"
            : showingPattern && pattern.includes(idx)
              ? "#555"
              : "#222";
          ctx.fillRect(x * tileSize, y * tileSize, tileSize - 2, tileSize - 2);
        }
      }
    }

    function randomPattern(level) {
      const minTiles = Math.min(2 + Math.floor(level / 2), gridSize * gridSize - 2);
      const maxTiles = Math.min(minTiles + 2, gridSize * gridSize - 1);
      const num = Math.floor(Math.random() * (maxTiles - minTiles + 1)) + minTiles;
      const pool = Array.from({ length: gridSize * gridSize }, (_, i) => i);
      const newPattern = [];
      while (newPattern.length < num && pool.length > 0) {
        const i = Math.floor(Math.random() * pool.length);
        newPattern.push(pool.splice(i, 1)[0]);
      }
      return newPattern;
    }

    function checkWin() {
      if (pattern.length === selected.length && pattern.every(val => selected.includes(val))) {
        score += 10 * level;
        level++;
        document.getElementById("score").textContent = score;
        document.getElementById("level").textContent = level;
        selected = [];
        pattern = randomPattern(level);
        drawGrid();
      }
    }

    function handleClick(e) {
      if (showingPattern) return;
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / tileSize);
      const y = Math.floor((e.clientY - rect.top) / tileSize);
      const idx = y * gridSize + x;
      if (!selected.includes(idx)) {
        selected.push(idx);
        moveHistory.push(idx);
      } else {
        selected = selected.filter(i => i !== idx);
        moveHistory.push(null); // optional undo tracking
      }
      drawGrid();
      checkWin();
    }

    function togglePattern() {
      showingPattern = !showingPattern;
      drawGrid();
    }

    function undoMove() {
      const last = moveHistory.pop();
      if (last === undefined) return;
      if (last === null) return; // skip
      if (selected.includes(last)) {
        selected = selected.filter(i => i !== last);
      } else {
        selected.push(last);
      }
      drawGrid();
    }

    canvas.addEventListener("click", handleClick);

    function startGame() {
      selected = [];
      pattern = randomPattern(level);
      drawGrid();
    }

    startGame();
  </script>
</body>
</html>
