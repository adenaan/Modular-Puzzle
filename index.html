
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Puzzle Grid Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
</head>
<body>
  <div id="log">Ready</div>
  <canvas id="game"></canvas>
  
    <div style="position:absolute; bottom:20px; left:50%; transform:translateX(-50%); display:flex; flex-direction:row; flex-wrap:wrap; gap:8px; justify-content:center;">
      <button id="togglePattern">Toggle Pattern</button>
      <button id="restart">Restart</button>
    </div>
    
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const toggleBtn = document.getElementById("togglePattern");
    const log = document.getElementById("log");

    const gridSize = 5;
    let tileSize = 0;
    let startX = 0;
    let startY = 0;

    let grid = [];
    let target = [];
    let showTarget = false;

    function logMessage(msg) {
      log.textContent = msg;
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      tileSize = Math.min(canvas.width, canvas.height) / (gridSize + 1);
      startX = (canvas.width - gridSize * tileSize) / 2;
      startY = (canvas.height - gridSize * tileSize) / 2;
    }

    function initGrids() {
      grid = [];
      target = [];
      for (let r = 0; r < gridSize; r++) {
        let row = [];
        let tgtRow = [];
        for (let c = 0; c < gridSize; c++) {
          row.push(false);
          tgtRow.push(Math.random() < 0.5);
        }
        grid.push(row);
        target.push(tgtRow);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          let x = startX + c * tileSize;
          let y = startY + r * tileSize;
          let state = showTarget ? target[r][c] : grid[r][c];
          ctx.fillStyle = state ? "#0f0" : "#222";
          ctx.fillRect(x + 2, y + 2, tileSize - 4, tileSize - 4);
        }
      }
    }

    function getTileAt(x, y) {
      const col = Math.floor((x - startX) / tileSize);
      const row = Math.floor((y - startY) / tileSize);
      if (row >= 0 && row < gridSize && col >= 0 && col < gridSize) {
        return { r: row, c: col };
      }
      return null;
    }

    function toggleTile(r, c) {
      if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
        grid[r][c] = !grid[r][c];
      }
    }

    function checkWin() {
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          if (grid[r][c] !== target[r][c]) return false;
        }
      }
      return true;
    }

    canvas.addEventListener("touchstart", e => {
      if (showTarget) return;  // Disable tapping when target is shown

      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      const tile = getTileAt(x, y);
      if (tile) {
        toggleTile(tile.r, tile.c);
        draw();
        if (checkWin()) {
          logMessage("You Win!");
        }
      }
    });

    toggleBtn.addEventListener("click", () => {
      showTarget = !showTarget;
      draw();
    });

    
    const restartBtn = document.getElementById("restart");
    restartBtn.addEventListener("click", () => {
      initGrids();
      showTarget = false;
      draw();
      logMessage("Game Restarted");
    });

    window.onload = () => {
    
      resizeCanvas();
      initGrids();
      draw();
    };

    window.addEventListener("resize", () => {
      resizeCanvas();
      draw();
    });
  </script>
</body>
</html>
